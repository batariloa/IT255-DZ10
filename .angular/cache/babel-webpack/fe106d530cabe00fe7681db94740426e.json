{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/home/dre/Documents/IT255-DZ10/IT255-DZ10/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _wrapAsyncGenerator = require(\"/home/dre/Documents/IT255-DZ10/IT255-DZ10/node_modules/@babel/runtime/helpers/wrapAsyncGenerator.js\").default;\n\nvar _awaitAsyncGenerator = require(\"/home/dre/Documents/IT255-DZ10/IT255-DZ10/node_modules/@babel/runtime/helpers/awaitAsyncGenerator.js\").default;\n\nvar _asyncIterator = require(\"/home/dre/Documents/IT255-DZ10/IT255-DZ10/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nvar _asyncGeneratorDelegate = require(\"/home/dre/Documents/IT255-DZ10/IT255-DZ10/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PreviousableTwitterPaginator = exports.TwitterPaginator = void 0;\n/** TwitterPaginator: able to get consume data from initial request, then fetch next data sequentially. */\n\nclass TwitterPaginator {\n  // noinspection TypeScriptAbstractClassConstructorCanBeMadeProtected\n  constructor({\n    realData,\n    rateLimit,\n    instance,\n    queryParams,\n    sharedParams\n  }) {\n    this._maxResultsWhenFetchLast = 100;\n    this._realData = realData;\n    this._rateLimit = rateLimit;\n    this._instance = instance;\n    this._queryParams = queryParams;\n    this._sharedParams = sharedParams;\n  }\n\n  get _isRateLimitOk() {\n    const resetDate = this._rateLimit.reset * 1000;\n\n    if (resetDate < Date.now()) {\n      return true;\n    }\n\n    return this._rateLimit.remaining > 0;\n  }\n\n  makeRequest(queryParams) {\n    return this._instance.get(this.getEndpoint(), queryParams, {\n      fullResponse: true,\n      params: this._sharedParams\n    });\n  }\n\n  makeNewInstanceFromResult(result, queryParams) {\n    // Construct a subclass\n    return new this.constructor({\n      realData: result.data,\n      rateLimit: result.rateLimit,\n      instance: this._instance,\n      queryParams,\n      sharedParams: this._sharedParams\n    });\n  }\n\n  getEndpoint() {\n    return this._endpoint;\n  }\n\n  injectQueryParams(maxResults) {\n    return { ...(maxResults ? {\n        max_results: maxResults\n      } : {}),\n      ...this._queryParams\n    };\n  }\n  /* ---------------------- */\n\n  /* Real paginator methods */\n\n  /* ---------------------- */\n\n  /**\n   * Next page.\n   */\n\n\n  next(maxResults) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const queryParams = _this2.getNextQueryParams(maxResults);\n\n      const result = yield _this2.makeRequest(queryParams);\n      return _this2.makeNewInstanceFromResult(result, queryParams);\n    })();\n  }\n  /**\n   * Next page, but store it in current instance.\n   */\n\n\n  fetchNext(maxResults) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const queryParams = _this3.getNextQueryParams(maxResults);\n\n      const result = yield _this3.makeRequest(queryParams); // Await in case of async sub-methods\n\n      yield _this3.refreshInstanceFromResult(result, true);\n      return _this3;\n    })();\n  }\n  /**\n   * Fetch up to {count} items after current page,\n   * as long as rate limit is not hit and Twitter has some results\n   */\n\n\n  fetchLast(count = Infinity) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      let queryParams = _this4.getNextQueryParams(_this4._maxResultsWhenFetchLast);\n\n      let resultCount = 0; // Break at rate limit limit\n\n      while (resultCount < count && _this4._isRateLimitOk) {\n        const response = yield _this4.makeRequest(queryParams);\n        yield _this4.refreshInstanceFromResult(response, true);\n        resultCount += _this4.getPageLengthFromRequest(response);\n\n        if (_this4.isFetchLastOver(response)) {\n          break;\n        }\n\n        queryParams = _this4.getNextQueryParams(_this4._maxResultsWhenFetchLast);\n      }\n\n      return _this4;\n    })();\n  }\n\n  get rateLimit() {\n    return { ...this._rateLimit\n    };\n  }\n  /** Get raw data returned by Twitter API. */\n\n\n  get data() {\n    return this._realData;\n  }\n\n  get done() {\n    return !this.canFetchNextPage(this._realData);\n  }\n  /**\n   * Iterate over currently fetched items.\n   */\n\n\n  *[Symbol.iterator]() {\n    yield* this.getItemArray();\n  }\n  /**\n   * Iterate over items \"undefinitely\" (until rate limit is hit / they're no more tweets available)\n   */\n\n\n  [Symbol.asyncIterator]() {\n    var _this = this;\n\n    return _wrapAsyncGenerator(function* () {\n      yield* _asyncGeneratorDelegate(_asyncIterator(_this.getItemArray()), _awaitAsyncGenerator); // eslint-disable-next-line @typescript-eslint/no-this-alias\n\n      let paginator = _this;\n\n      let canFetchNextPage = _this.canFetchNextPage(_this._realData);\n\n      while (canFetchNextPage && _this._isRateLimitOk && paginator.getItemArray().length > 0) {\n        const next = yield _awaitAsyncGenerator(paginator.next(_this._maxResultsWhenFetchLast));\n        canFetchNextPage = _this.canFetchNextPage(next._realData);\n        _this._rateLimit = next._rateLimit;\n        const items = next.getItemArray();\n        yield* _asyncGeneratorDelegate(_asyncIterator(items), _awaitAsyncGenerator);\n        paginator = next;\n      }\n    })();\n  }\n\n}\n\nexports.TwitterPaginator = TwitterPaginator;\n/** PreviousableTwitterPaginator: a TwitterPaginator able to get consume data from both side, next and previous. */\n\nclass PreviousableTwitterPaginator extends TwitterPaginator {\n  /**\n   * Previous page (new tweets)\n   */\n  previous(maxResults) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const queryParams = _this5.getPreviousQueryParams(maxResults);\n\n      const result = yield _this5.makeRequest(queryParams);\n      return _this5.makeNewInstanceFromResult(result, queryParams);\n    })();\n  }\n  /**\n   * Previous page, but in current instance.\n   */\n\n\n  fetchPrevious(maxResults) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const queryParams = _this6.getPreviousQueryParams(maxResults);\n\n      const result = yield _this6.makeRequest(queryParams);\n      yield _this6.refreshInstanceFromResult(result, false);\n      return _this6;\n    })();\n  }\n\n}\n\nexports.PreviousableTwitterPaginator = PreviousableTwitterPaginator;\nexports.default = TwitterPaginator;","map":{"version":3,"sources":["/home/dre/Documents/IT255-DZ10/IT255-DZ10/node_modules/twitter-api-v2/dist/paginators/TwitterPaginator.js"],"names":["Object","defineProperty","exports","value","PreviousableTwitterPaginator","TwitterPaginator","constructor","realData","rateLimit","instance","queryParams","sharedParams","_maxResultsWhenFetchLast","_realData","_rateLimit","_instance","_queryParams","_sharedParams","_isRateLimitOk","resetDate","reset","Date","now","remaining","makeRequest","get","getEndpoint","fullResponse","params","makeNewInstanceFromResult","result","data","_endpoint","injectQueryParams","maxResults","max_results","next","getNextQueryParams","fetchNext","refreshInstanceFromResult","fetchLast","count","Infinity","resultCount","response","getPageLengthFromRequest","isFetchLastOver","done","canFetchNextPage","Symbol","iterator","getItemArray","asyncIterator","paginator","length","items","previous","getPreviousQueryParams","fetchPrevious","default"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PreviousableTwitterPaginator = exports.TwitterPaginator = void 0;\n/** TwitterPaginator: able to get consume data from initial request, then fetch next data sequentially. */\nclass TwitterPaginator {\n    // noinspection TypeScriptAbstractClassConstructorCanBeMadeProtected\n    constructor({ realData, rateLimit, instance, queryParams, sharedParams }) {\n        this._maxResultsWhenFetchLast = 100;\n        this._realData = realData;\n        this._rateLimit = rateLimit;\n        this._instance = instance;\n        this._queryParams = queryParams;\n        this._sharedParams = sharedParams;\n    }\n    get _isRateLimitOk() {\n        const resetDate = this._rateLimit.reset * 1000;\n        if (resetDate < Date.now()) {\n            return true;\n        }\n        return this._rateLimit.remaining > 0;\n    }\n    makeRequest(queryParams) {\n        return this._instance.get(this.getEndpoint(), queryParams, { fullResponse: true, params: this._sharedParams });\n    }\n    makeNewInstanceFromResult(result, queryParams) {\n        // Construct a subclass\n        return new this.constructor({\n            realData: result.data,\n            rateLimit: result.rateLimit,\n            instance: this._instance,\n            queryParams,\n            sharedParams: this._sharedParams,\n        });\n    }\n    getEndpoint() {\n        return this._endpoint;\n    }\n    injectQueryParams(maxResults) {\n        return {\n            ...(maxResults ? { max_results: maxResults } : {}),\n            ...this._queryParams,\n        };\n    }\n    /* ---------------------- */\n    /* Real paginator methods */\n    /* ---------------------- */\n    /**\n     * Next page.\n     */\n    async next(maxResults) {\n        const queryParams = this.getNextQueryParams(maxResults);\n        const result = await this.makeRequest(queryParams);\n        return this.makeNewInstanceFromResult(result, queryParams);\n    }\n    /**\n     * Next page, but store it in current instance.\n     */\n    async fetchNext(maxResults) {\n        const queryParams = this.getNextQueryParams(maxResults);\n        const result = await this.makeRequest(queryParams);\n        // Await in case of async sub-methods\n        await this.refreshInstanceFromResult(result, true);\n        return this;\n    }\n    /**\n     * Fetch up to {count} items after current page,\n     * as long as rate limit is not hit and Twitter has some results\n     */\n    async fetchLast(count = Infinity) {\n        let queryParams = this.getNextQueryParams(this._maxResultsWhenFetchLast);\n        let resultCount = 0;\n        // Break at rate limit limit\n        while (resultCount < count && this._isRateLimitOk) {\n            const response = await this.makeRequest(queryParams);\n            await this.refreshInstanceFromResult(response, true);\n            resultCount += this.getPageLengthFromRequest(response);\n            if (this.isFetchLastOver(response)) {\n                break;\n            }\n            queryParams = this.getNextQueryParams(this._maxResultsWhenFetchLast);\n        }\n        return this;\n    }\n    get rateLimit() {\n        return { ...this._rateLimit };\n    }\n    /** Get raw data returned by Twitter API. */\n    get data() {\n        return this._realData;\n    }\n    get done() {\n        return !this.canFetchNextPage(this._realData);\n    }\n    /**\n     * Iterate over currently fetched items.\n     */\n    *[Symbol.iterator]() {\n        yield* this.getItemArray();\n    }\n    /**\n     * Iterate over items \"undefinitely\" (until rate limit is hit / they're no more tweets available)\n     */\n    async *[Symbol.asyncIterator]() {\n        yield* this.getItemArray();\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let paginator = this;\n        let canFetchNextPage = this.canFetchNextPage(this._realData);\n        while (canFetchNextPage && this._isRateLimitOk && paginator.getItemArray().length > 0) {\n            const next = await paginator.next(this._maxResultsWhenFetchLast);\n            canFetchNextPage = this.canFetchNextPage(next._realData);\n            this._rateLimit = next._rateLimit;\n            const items = next.getItemArray();\n            yield* items;\n            paginator = next;\n        }\n    }\n}\nexports.TwitterPaginator = TwitterPaginator;\n/** PreviousableTwitterPaginator: a TwitterPaginator able to get consume data from both side, next and previous. */\nclass PreviousableTwitterPaginator extends TwitterPaginator {\n    /**\n     * Previous page (new tweets)\n     */\n    async previous(maxResults) {\n        const queryParams = this.getPreviousQueryParams(maxResults);\n        const result = await this.makeRequest(queryParams);\n        return this.makeNewInstanceFromResult(result, queryParams);\n    }\n    /**\n     * Previous page, but in current instance.\n     */\n    async fetchPrevious(maxResults) {\n        const queryParams = this.getPreviousQueryParams(maxResults);\n        const result = await this.makeRequest(queryParams);\n        await this.refreshInstanceFromResult(result, false);\n        return this;\n    }\n}\nexports.PreviousableTwitterPaginator = PreviousableTwitterPaginator;\nexports.default = TwitterPaginator;\n"]},"metadata":{},"sourceType":"script"}